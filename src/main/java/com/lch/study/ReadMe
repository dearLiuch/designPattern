 todo 不是很理解，反复去消化学习
todo:整理每个设计模式的使用场景、设计思想、代码案例、优缺点、源码应用等；反复琢磨理解消化；
频繁创建对象组件基本上会用单例；创建数据库的连接用到单例

	  恶汉和懒汉
	  将静态类的引用放在静态方法里面，方法类在实例化时，静态
	 
	  恶汉：会提前初始化，调用的时候就不需要再去初始化，这个性能是好的，但是它的缺点的话，
	  他就是会浪费你的空间，因为你即使不用它也初始化在那儿
	 
	  懒汉的话，其实就是一个延迟初始化的一个手段，
	  你调用它的时候，它才会去初始化，不动它，然后它就不初始化
	  ，那他就是解决了这个恶汉会浪费空间的问题。
	  实现方式：将引用放在静态方法里，在类实例化的时候它是不会实例化的，
	  只有静态类不会实例，然后静态对象是会在你对象实例化的时候把静态对象实例化出来
	  就是我们讲GM的时候会讲内加载链接，初始化的时候是会初始化的静态对象的，然后静态方法是不会初始化的
	 
	  双检锁：volatile高频面试点；可以保证可见性，但不会保证原子性；阻止指令重排序，
	  双检锁：两次检查，中间一次加锁；
	  加锁不是原子操作，加锁的对象可能已经被初始化掉了，所以在加锁完毕后，还需要再去判断一次它是否为空，如果为空，再去创建
	 
	  理解指令重排序：一些CPU在计算过程中，如果指令前后没有逻辑关系，会把指令顺序重新调整的；
	  volatile保证可见性，但不保证原子性理解：
	  你平常在操作的时候，它是有一个主内存和工作内存的，然后如果说你没有加入volatile，你的数据是放在工作内存的，然后你对它进行操作，它还需要从工作内存刷到你的主内存，
	 那这个时候如果你加入了volatile，它相当于就不用你的工作内存,直接用主内存.相当于你整多个线程对这个对象操作的时候，它多个线程的对这个结果是可见的，
	 这个对象操作的必是立马可以看到的
	 但是你这个虽然保证可见性，线程a修改后线程B是可以看到的，但并不能保证说你这个一个非原子操作。
	 比如你一个非原子操作i++，它只能保证你i+1以后，线程Ai+1以后立即可以看到i+1的结果，
	 但并不能保证说你同时线程A进行i+1,线程B进行i+1，结果还是2。

	 解释为什么要使用volatile防止重排序（理解很重要）；

	 单例模式是可以通过反射被破坏的，怎么防止反射时不被破坏单例？
	 加上非空判断即可。

	 volatile原理：
	 加了一个lock前缀指令，那他通过这个指令就是我们所说的那个内存屏障，然后内存屏障它其实是分很多种功能，
	 然后我讲我给大家讲几个最重要的，第一个就是说它的，它保证你指令重排序的时候就不会把后面的指令放在你这个屏障之前，
	 也不会把你屏障之前的指令放在你这个屏障之后，然后就是在执行到你这个屏障的时候，他一定能保证你屏障之前的指令全执行完了，
	 而且它会保证，假如对写操作的时候，他一定是会导致这个cpu其他的对应的缓存是失效的，
	 其实这就是可见性。可见性分两步，如果说你的有缓存，他写操作的时候它会导致缓存失效，另一部分是无缓存，
	 那这个时候将你这个缓存里面的修改直接写入你的主存里面，这就是他的可见性。

	 Spring bean源码里：单例模式、代理模式、工厂模式，组合起来用的；
	 对SpringBean单例的理解，结合源码多次反复理解；

