// todo 单例模式要反复看博客理解消化知识点，找源码及项目知识点应用起来
什么是单例模式？
保证整个系统中一个类只有一个对象的实例
如，频繁创建对象组件基本上会用单例；创建数据库的连接用到单例

单例模式为什么要加final?
final可以修饰类、方法、变量：
1.修饰类：类不能被继承；
2.修饰方法：final修饰的方法不能被重写，同时，被final修饰的方法会被转换为内嵌调用的，不需要再去入栈出栈
3.修饰变量：基本变量，则基本变量值不可改变；修饰引用类型变量，对象引用类型在对象初始化后就不能再被修改了

为什么单例模式用要final？保证它引用的对象初始化之后不会再被修改了
不用final，并发场景肯定会有问题的

为什么要使用static？
构造函数为private，不提供对外创建对象接口，通过static静态方法getSingleton()提供对外获取对象singleton
所以，singleton必须要用static修饰

饿汉式:
优点：没有线程安全问题；
缺点：提前初始化会延长类加载器加载类的时间；如果不使用会浪费内存空间；


懒汉式：
解决线程安全、延迟初始化（你调用它的时候，它才会去初始化，不调用，它就不初始化，解决了恶汉式浪费内存空间问题）
实现方式：
todo 后续学习完类的加载机制，再回头理解这个加载过程。
      将引用放在静态方法里，在类实例化的时候它是不会实例化的，
	  只有静态类不会实例，然后静态对象是会在你对象实例化的时候把静态对象实例化出来
	  就是我们讲GM的时候会讲内加载链接，初始化的时候是会初始化的静态对象的，然后静态方法是不会初始化的


双重检查锁：
volatile高频面试点：可以保证可见性，但不会保证原子性；阻止指令重排序；

volatile保证可见性，但不保证原子性理解：
    平常操作时，它是有一个主内存和工作内存的。
    没有加入volatile，数据是放在工作内存的。然后你对它进行操作，它还需要从工作内存刷到你的主内存。
    加入了volatile，则不用工作内存,直接用主内存。当某个线程对这个对象操作时，多个线程对这个对象操作结果是立马可见的
	 todo 对volatile不能保证原子性理解不够透彻，待巩固消化
	但是虽然保证可见性，线程A修改后线程B是可以立马看到的，但不保证原子性。
	比如你一个非原子操作i++，它只能保证你i+1以后，线程Ai+1以后立即可以看到i+1的结果，
	但并不能保证说你同时线程A进行i+1,线程B进行i+1，结果还是2。


在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，重排序需要满足两个条件：
1.在单线程环境下不能改变程序运行的结果；
2.存在数据依赖关系的不允许重排序；


为什么双重检查锁要使用volatile关键字？
Singleton singleton = new Singleton();
经历三个步骤：
1.分配内存空间
2.初始化对象
3.将对象指向刚分配的内存空间

发生指令重排序后，可能变成如下步骤：
1.分配内存空间
2.将对象指向刚分配的内存空间
3.初始化对象

若不加volatile修饰singleton变量，则线程A和线程B会发生如下情况：
线程A：检查到singleton为null，获取锁，再次检查到singleton为null，为singleton分配内存空间，将singleton指向内存空间；
此时，线程B到来，执行getInstance()方法，检查到singleton不为null，就去访问singleton对象了；
但此时，singleton还仅仅是线程A将它指向内存空间，并没有完成singleton对象初始化
在这种情况下，线程B对singleton的访问，访问的是一个初始化未完成的对象。

使用volatile关键字后，重排序被禁止，所有的写操作都发生在读操作之前；

单例模式是可以通过反射方式被破坏的，因为通过反射方式可以直接调用私有构造器

单例模式是可以通过反射被破坏的，因为通过反射方式可以直接调用私有构造器。
怎么防止反射时不被破坏单例？在单例类的私有构造函数中加上非空判断条件即可。

volatile原理：todo 加深理解，不断巩固
加了一个lock前缀指令，那他通过这个指令就是我们所说的那个内存屏障，然后内存屏障它其实是分很多种功能，
讲几个最重要的，第一个就是说它的，它保证你指令重排序的时候就不会把后面的指令放在你这个屏障之前，
也不会把你屏障之前的指令放在你这个屏障之后，然后就是在执行到你这个屏障的时候，它一定能保证你屏障之前的指令全执行完了，
而且它会保证，假如对写操作的时候，它一定是会导致这个cpu其他的对应的缓存是失效的，
其实这就是可见性。可见性分两步，如果说你的有缓存，他写操作的时候它会导致缓存失效，另一部分是无缓存，
那这个时候将你这个缓存里面的修改直接写入你的主存里面，这就是他的可见性。

todo 后期查看Spring源码，理解下面内容
Spring bean源码里：单例模式、代理模式、工厂模式，组合起来用的；
当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法）
此时要注意了，如果该处理逻辑中有对单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题
