命令模式使用场景：
当需要向某些对象发送请求，但是不知道请求的接收者是谁，也不知道被请求的操作是哪个，使得请求发送者和请求接收者解耦

最简单的命令模式：
遥控器和电视机（命令的发送者和接收者），电视机收到命令后，执行比如播放等操作；

命令模式定义：
todo 待消化这部分内容，通过代码编程理解命令模式的定义
将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；
对请求排队或者记录请求日志，以及支持可撤销的操作；

命令模式优点：
1.降低系统耦合度；
2.新的命令可以很容易加到系统中；
3.可以比较容易设计一个命令队列和宏命令（组合命令）
4.可以方便实现对请求的undo和redo
即，命令模式最大的优点是：可以做一些列的命令doList、redo、undo操作

宏命令理解：todo 待实现加深理解
比如，回到家，执行一系列命令doList：1、开灯 2、放包包 3、洗手 4、喝水 5、开空调，
放到Context中，此时Invoker可以调用这个宏Context，

redo和undo实现思想：todo 待代码实现加深理解
redo：重复做这件事情 undo：撤销
redo和undo基本的实现方法是通过实现一个命令栈；
有一个栈，保存命令操作记录list，比如你执行快进操作，那么队列里就有个快进的操作记录；然后，做redo时，就从队列中拿出快进命令，
再做一次快进操作即可。如果是做undo，一定还有一个映射表，然后从命令栈list中拿出快进命令，然后从映射表中拿出映射的undo命令（如快件的undo命令对应
的是后退操作），再执行undo操作；
基于命令模式，还可以做命令的优先级、自排序、

命令模式缺点：
使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每个命令都需要设计一个具体命令类。

todo 理解为什么使用命令模式？不新建Command命令类，仅新建Clinet和Receiver类也可以调用，命令模式的好处在哪里？
todo  怎么实现命令模式中的doList、redo、undo？



静态代理模式缺点：
代理类太多了，不知道用哪一个代理类；
比如，打印日志，加一个代理类；想做一个校验身份的，做一个代理类；判断用户是否是黑名单，又是一个代理类；
整的代理类就会非常多；而且每次整代理，都要修改这块代码；其实就是耦合度太高；
Spring支持jdk动态代理和cglib动态代理，面试经常考；
jdk动态代理通道反射实现，它的核心是实现InvocationHandler接口，而且它一定是要有接口的；
动态代理的设计思想和实现过程要掌握；
反射时需要传递的三个参数要熟练：1.对象的classLoader 2、实现接口 3、代理类handler --重要考点
jdk动态代理的缺点：业务类必须要有接口，为什么必须实现接口，在源码里面有体现：
jdk动态代理不会修改字节码，最大的缺点是必须实现接口，因为在源码里会对代理的是否为接口做一个校验；
cglib通过继承，修改字节码得到代理对象的，它的代理类会生成两个方法，一个是真正的方法，

cglib代理类是通过继承目标类实现的；它的代理类会生成两个方法，一个是针对真正的方法private，原模原样生成字节码，
还会生成一个orlad的方法，这个方法就是cglib通过代理来修改字节码生成的一个代理方法，生成这个方法以后，在调用时，
cglib通过new Enhance()，enhancer.create()调用这个方法的时候，它这块会生成代理类，然后在调用sayHello方法的时候，
它会判断这个MethodInterceptor里面是否有拦截过的对象，如果有，它就调用刚刚我们加了orride的对象，它自己生成的那个对象，
如果没有，就调用原来那个原模原样的方法，这就是cglib不通过接口实现就可以实现动态代理的原因。

cglib一般（不一定是一定）是要比jdk动态代理要快的，因为cglib修改字节码有可能快有可能慢，
它快是快在cglib是通过索引，生成代理的时候它有两个方法，一个getIndex，一个invoke，
getIndex做了一个操作，它在生成代理的时候，对你每一个类建立一个索引，根据方法名参数来去生成一个索引，
他这个东西叫fastclass，fastClass这个机制就是先建立索引，调用invoke时，不需要通过反射去调用的，直接根据参数名入参通过index
找到这个方法，可以直接调用，不需要通过反射了。
慢就慢在asm上，不一定比jdk生成的动态代理快，

cglib两个重要知识点：
通过asm通过继承去修改字节码，
fastClass会建立索引，通过索引加快调用，

一个过程，两个阶段：先生成，再调用；
通过字节码生成class的时候（生成的快慢），fastClass调用invoke（调用的快慢）
生成class后一般是有缓存的，fastClass通过索引调用会比较快，但是初次调用的时候，和jdk动态代理差不多

jdk和cglib动态代理的区别是重要考点。


装饰模式：给你的对象提供增强的功能，主动操作实体类；继承，更多的是用组合去实现。
代理模式：所有对对象的访问都交给代理类去访问了，把你的业务类交给代理类去操作。代理实现就是上面三种方式来实现动态代理的。

观察者模式理解与设计；



六大原则，其实就是解耦。
